<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52e8ca756d9a518a79ae6f6d191a7f44ffa2eade8831db1fe16f6e55b20dd429534cb35bc275f8045326ceb02c546ffd68e1d36c2f9146b20fe5659c549edb7bf1dd2e39f30d96860fdf9cfb8e8c3a45954b990013853c0bac19d6c5e4081a2fcd61b73c1d9ed70d5eb329a01bcde71a97026412e31ae282cda9e2634ad4d0560dbfedd97fd08e4af12514ea06b8af42892152854080a1904f3ac3646b01c8fd265ac83bee5f87683e72756c7f9806f5a4f5c59e096ed818b818efde29af5cc4ddeda5a39bbb3de3cdb7af6b7f6b5f6af999eb2ee47df2ce39214def5b5c7800c24bc6cc4c6b18878cf557e850d48751f6ead127b4a81f369b16a9d00c2a829f74062df1198099ee7db5f2ca636c225478019e5a78055ee0f13b8a4fea779ad1be7fe380178db3e870eb04c7ef0d11a3bd62c6293b21805fd9874888a4017c0f3ed27e3587111441d5980425eeb03c5616e0c41cc5e45a9948dff91863a775d376a405168558ad5584b9ee76a81bc3906552536f87e01dcaad04c328336f982d7731df5cfddda4a23702939a1946b52e04533af2a5f3e2174fc3076010e69213c8923b18e12946e1be439ab9803d07862d30a4033199c2e1d3418f4dba0789bf5e41aee0f62a7c4572b07a588c968362e943a8430264fe3316c621be39894da92fdcad9cc4f2668fcf50824f4f10f7498b7fb8cf59f78532940c3e944406ccebf1c7825e614baf4dc7479320fb6dcaf86dcbf9c27cdecef7dbd432c84c93f03f18ac8f5578d9f182e5d091e2beb436e8cfa10ff3f29697adbf382061f2699145792b7bcf6ac0b2a70bc7d1452f2a6a31a3092961b5b9981d6b4195f5249db6ef2d283dbf5cd4ba09a909149ff8d326b0f246653de641f4d91ea49c27d766ede16000b921a9a8c43041411378d71c9294abe4fc66743c8c41ad9bdef8843f42d14edd50f91d1238a667bd7f659133657d42798b81ad6e09686fce60b89bde4a10f5e64bf53daf04454d19fbc1724dbaf9e5877c28789d79b239a0b2b7347fe2e38d9213f490dd17fa7211d56ebffe7f46c0651affde5e8498eeea46cbdfbde89de5b6737fb0cd5159c8b19663567905bd2a3c717f74bd2f5798baf694608167ec0faa5a70ccad53c7b56ca785b77a739e4bb2f0ecd0526e51578ca5efc3e844bfe23990e0e0737f162c848c96648ba5eaade0699b264dffd9998cdadd5ec4fc83fe521f9e1ebd298fb691fdb553884fd8df0f6d52b1d72183b2751806ab44885a9c145da4f91fae6ed72d4472ac37816547dac1de557d3353df92e08f600a1f7c27cad0f8ac01addb2723fe3abdabb294e4c442486c551c44b1c8fc9bee2c32c028fe3016faa73c4d51f5ea4434122808a63a9f7cc5ede94814dcde82ca5ef4ce6292b70aebb85b8f009a1b811115336693feb8706d61e7e556589f84dc89df40093cefe677ed5bd55be9daafd05716af4385809cb1362103496157e188546de3fa854271252be5071cc2ea487f299b3f2ee27e1104d18bef2be0b03477330bc5ed75992dfa80303b361fe3e28bbd7e9efeabbd307c6ead19b6c99d1ce4140971d8d8101cecf247709b2f417bddad8cbe209c67287fa79b55172d379bad19a4022a22ab8913b19a69849868e97ee559709f14b793e249b206408856188f6836b028bee931afcf0247215dd1ad0b6b32af7210138eb78d02e4d86dbb3b8d1a1a7b0c5f50cd785213195ef998abc55a35ebeedaaeb3be68cefce2405a471da420a5c1b747fc87716b26c438d8c1b83576117852c2b4b7e9523f8783d2ea3d5e38aeb5d859c9d7e4cf268b2f10c39ba4710e10f33776fb379c7c4febcdf71cd2f2b08efafd0da2f2132e208a7fe358821968e86cdbd777c3fc3222991925f0b2fa50c49b982ef2fe083ab2bffb5af9a9e6b4475e8a235fc5f176bf1916b50caf23976cebc777ffbc0f22ec64291dde8d0edff194fcb23571296ab74274225677a5b8deccd0ccc4fa32c33f02bbaca20a4a2de3d700ff7bdb8707f2d27727a167651ee234a2767c3f15c386cb0b48b4019cba137d958442044a057f81165a269a396d9f59d750053b979d160f7b61b848e6161d6e3c52d318e8c520326c9af06ee1bdccddbe8966c7f25bbb6cdf40cfc6f5b53b3660736d38c0832384f2ae4ff8af69b14a3c30453147a953562ef638dbae2a55eaf733188c09eec25b15d631bfa3dc4bec2ff4142afaa5d82550967521ff2efaa62e36e8cccc7b0c071b6f649e317b71fe229b39f55ec089982efa0e536cfd057675b16334a1ff8a01c8e23f395b6e7391d721a1a7da6c8e29f4adb73292b0b8648d0c7e3a5beb27f2b4794eec77c8b1b8605af8bbcbe70590cfef9c307fbeebc7175d638de4c03c369e9823f4e23623c81159e7020744380829389dc7f091c353d441e8f0c6356b54cad7b2eaf93eee97da57a1189d775c0eb75c2e9d2be9f5688d7a1a69297b146c220d399a7a97f37626bd38ef9478429342ff035f633cecc019da23fa6dd405e18382f2061db52b3d40aff9b3f81e0203ed9031a539fed3d76b2441171d0739df46ce03352d3fd7a361316523a6cc95fa632fb8dfe2c6d68efa3e32f901d8f595758d449ea08737534625b674d171bee0fa251af06d3e77d59b8f6cb538c970bf942f46126485fdef04fbe06d8c5af89e23d8e37f7b7efd81aa2628933543ac5a063dbe15890efc532c127ed32e651de1ad47b6ba413f37007223b93dbd2243d249cde947238870a71f52aa363990db144d7db23361882d65807a806a563c665d52b491ac5dbca935a8fd61e98a4948b76e8cb3b1e85d5a689b6e84a8ed7711ef15630712ff44321d2881a435123349ac2721d4a3fffe3ccfec22a6ad76eb7590a0c53d9fb969188f23218d5681f6de63c5e9d295339bdc097c3581412020a195ac696a3c937c664345042e9b3da0d09598c0f100c74e83afbefbe6e752b195224ded569f9054e242a8de0ae22fa8f971eb8d1e527be5533078114e119c8f76cf6d05b8ebfece79ea7408492fa03971bc77853ee7f87d79593d6043f55ae96e42a2c562cea528a193fd4a629df3b997a93799c29797b3858f376553e42538be0a565987199bc0c8711ef0d81ee17f77d8b953a672569879f3cceae3302d44884b65fcf371dc358f9ce0f771745715a4dea485926ff6b62fe2ed6a3a81ed6a425f128b56df60efe53dd0745dc8a73efcc78520da3d5ade72fbcef1abac252414017d7186cce230d81a3f25fe38503e9ca6ccd3014ae2ece6d2bd4976e380373fda8b23c92484a1db156962a190a4ffe73f0a864782667f421e2f809a71f16a8b9937480e66741d148e0f02f53bff47d4835bd66530767cf5770ea9bf3805fd13236024ca91c9607e947d3b81f45c9d90b3629c199531cfbf114d45955f79119d257018385bb846a50f5d9abfc4884e3c4d8a8bc6eb0dd15fde2d9aedbc058a46ca9c05af5a610ddc5da12d696e4b8b9362ce3dc133557147114d0fc2f67f9c37e351d695bc75eeae2fda8176b12313fd4ac553a2bcadf7d0c870c4ec812f183b06cb82f5175a971460841f8bdf54a75885bea94d33b6a6d8b673f8fa68591a77ec2538af9023d7adf4ab7e809166681d9136b4d69b5e70e8fdd90848f5e2b12298e5b6010a176dfb69afb316025c6391d82efaef39c2aacd2223bb3725959de2556c539628dd99f471008736fbd4cdc6299ff0f3e4ecb0c64f09f9984def2fd0e480571a6e0953beaad3ab872d5644ccc1ad8608b9def3025a80936f4f0e9a86dd1c5082f2cb929757d178019b84342fea78e88a6209716b6a2225544ed6cb101ad024e6fb49ded8183690039b3801bef7ec443a787947c725732d054432185d02cbc9908de0ae1a6b79af778153e4269e8aa9b5a30a2b328495b32828aa2f5b02dae8d45ab2161b1f040ffc18d1e09925c91d37d34cf1333ad71df7df4d8088b14fbaf665cac1dd8fdd353fa50f8b1562328383650a4354cee7c578c7b97034791115224f93b901e88f20b224ab86b16f337b2c71ccf08cbf6adabc0b2cc2a24fa19f8b46e6805497650e797df66d29212cbc006156799f156ffca2a2f2ad504d2a5d07faad6b7638da96773b8805945e719ebc459e3e379be6d1c9b086c383e029e1ffb071916de5c0b3f1c1f59fe86505f77547408d714cec64115f19478f4a6ecb044b849da256b2d8d3f8523c70a2eb9ad9d13872b723d8049e44b1d30828dad6657f71638f7836ec5ac513a6d181b0c765f2086a1626c26d73086542cb81fe715cc74cd3f7de6d979351d1a1446477dbc34912ad49d57bef26d64fc9fce156ff224c9262a0a737fba09a12615e3cb6fbf4ef2438bd0ef3452492771a242f4ec515b0a265c259d7d60bb450fdb978ee60f50cb17dfe97ae11d54a7b7d3648d48cbe47b349a0158e657f92b423dc1d26db987bc978e853168e86961ed7b0732d21816e571fc5a51a350497edb3ce288743bd218e4200c0c7d62d384162dcaf7d5ec1f51a548bf6082758f7886aaa045d78aa1c52c04a1f78916a093472edf1e350c010b2e3b7e1d70121086f0ccd978783742ce25a52c46717cf189b7216e733e06fc6b5419b7b7e23973591846002b4a2e2df27d0fb4b462c2e3fd34eff5a5424844ac257e60583ee3c0c2a1ff97e222fdb61669fad0c25b1ee7ee534bd691fcadd5661b1e1acf882ad265150b7858a66958c2409ef23b37d8eae4b4341b8f2f2084356376e519d5c931b093abc31c3b6e590d00f4d1d91899473d9887cbe75b8604f7416cdaca1b6a431a2b945771b6f18a8fedaa5519f957141169477e8ef36d81dda51ba901b572cfa03400f84f65dcb702244980c68e543905537575304d0c7b93f24f3bdbe23a11943f069a06b997f1d5051be7a0cf340edc397e6472bbef014cf17e3d2ba97a104a05cf63529627309500a54b2eb0d0ae6bbb48489091a042661b3ab7f489cc924a9f424bcbf6ee9a5b9dad8ae0963d40a3cb45ad3d575e8937e3d6cd779ad338b6dc5452979a8a000b6cf93f98993c43689abb89891967ce22ff3e91c3187b5caa31fe1812af22ed5df660c9b79af69bc8cab1c678011eef4e9d6b6c5ae3820e13499123b0b3681fad66102c6c433239fd4ada787668f7b3e6facca6858eb3f4fe88afb415a5e57566b9f3a2f3219c66cfbbe3f3b1fc550c3026fe5052442a19aa138bf181dfe912b247a6ab7e5dc1be7acccb9abf0aa930e0d80afd2b640ef4ed050975ca7d82604ccac3967d3436d49a59b1810e7284b5aed5612d70b95fa9ee7f35aefb226b020dd88c8b34704aafea3d2bdd6240a1e335b8a6c09e77ee961e90d66432e1e08fc567da82f036e656b3fb4e80ecf2146f39302d4dd0e3c74a61cff7cca055f7a17f2db21d66438545d4bcce35d7a89a2c41d989ff5c81dbab8da5b9aa3fa8a25b427dfc4c7d7e79429ef0e3a58c1452b3839ee4c359fb6e7d67637ce3210ec041115c9bcd98f09b9df9ea024ef811898f17f2cf743601105e6eb564152918d3f2be12f3ff91320602e27b876d576b2e5bf66864c532e6eae936aecd9a85c13b747cc9003fe95724f8e5bac0e5ce12ce2c717018a657746b291ef00e9010ca8621466c39704ae3eab6e8eda5321ee640eb9cb3941eb7fdf8ec87f1d02fc4b4d012a8a3c031d724dfdf846afd0a7b8fe9c28a3e85f7471f14ff07213d49b4c770dbb2563b37406ef1b14a5fc8b4c18f83ba0dffbcccb940b9085e1904cbe19ac276bbdb456c0ee09ed3ec785b7e4c4545098e43c31c86c013b62452320ee20050254e32e6131815c34ce6acf4b2c78ce5e0361f6a73aa6ba4eae4b77d0b676095a4e3f6e93bfc3b870321512143c515e75c1a5d2c609f91fd1c7f92a2e0f99144a457e8dc446610d6951e4aea56e058167ad8aad891d48f64745fadba0004738c676e4ee9bf58829867660fd145a2d8481ac268d22311a6a9238b2f2f86dd524b1f96c867e02679513e442bd1ba57a308dd5b7648eac654ee372a3c918eb39fc8f47cfe047eda48fdbb97d0d12bd6cdd5c8ac7b666b62bb67a9021ccd3c0cf535471ae032a4d8454017ff210318f53a13923f015369aa80e05da6c71cb7d76c0be82d763fd060e62a067b3728e5f4b9b5f8f5fffa3376a23bc254bb40a5279e08febc8c6f079d37141d39bcbd3682c029c946e50b0475cb1aaea9bc49a25ac1ec29931765c228467c65e0db4bb242cc542e05de62c1a5aa653af9afe01875dec3a1303ab5fbc00fe1b37af8fd6c0e8eaf3654d200868842c8cae77e88fbf2c9879278a8ad4fef3c6b1a76cd622fb3cfeb497dda1ca74fc9b34a9c34aa2c72653224982b2eca3b79bb577ad72b034771747c5e2955d93a15b3ed56c32ed4fa3ed49874c9161fa1bd60035ac10598576b4045512684e7e77548acfc148f67ca2ca877a33055c841dd46f95b7c91644f9ddec3a6a76caa61b51fc6d4ad3d1847dc0bcac05f19893f68babc21bf294fbf8c246cfaad3dadf228c0194588d9321fb2a4f34a06a81ee359498d6d4c451d1b7804b41d6552504dd2a2d60dae7b7d0e6829eab2b779cbedae81aefa48d013c5bf973289ca4039dbbf7e1f141119df40001ee8047655c97012cadb837d0a980ec06589db0c1e67d5f3a1761c3b5d6bd29d85da7434eee852089c6e67b642cc9c60fd1f15cf83a45b063d097cbfcbc7c4189adf20955b5e8f77e53d23fe4079f1ffca865834acc1c09dd958fa1437142c9253beb72704cd828e8ba14f367ec19375c61fc79b758ca66d0c5f8538fe6fe9e32c4770ae9ddfbb78ecdef0a965e01a55af97bfd69e32a1f5458dea64190ef48599b64ca05af140599735bb4ea641ec640d9be40576aaf954d52baade9601213d01f7ea42a04dfdf9aee4691928300c96644c1a987ea3c221a40918d7abacc1bdabe6672b7e3a9913c7ff5edef2c8dab9f19150bdb535e351ad148f9fd812c8938a5609ec7c857185f01485487b6228b1d50d537a8c5c782fd296655acfb27eb9be74c575f93cbd4fc8fb6cacb7a7f33bdba092c611d4bfcee18f48062e7a2de925619252135b83c7a32563f30decd25e612922ccc439af47515714699329e9aaaeb99554a27ba861e73b1c549e92308bf29bdd5230bcd13eea79c501e93015247a863ff4b4b6a7a7ad1f8337246ff9327db2ff769bf24fde6a97c7cee5f44e2d3ce5b2d9cb94a857aa05fea4e27d1467d69961f8ba49444d54cc741d66136238876f784f0a380d1e34cee4b8f4b1f3a1f4182ae0d21e5787fee5d6b2d23c0465787755cf7f203c9e8cb90df790cf44daf30eac82d8ac3cee67841b2520cfc762997f44559ed8b8a10bfc1b2ed58b4b13356056c5c4a608d41751c891bb2a00aac71410daad731202701e0053883fe3011762c5a3337cdbb9aaf4ca799ef80403f821b8ea686e7602f7f605cae764ff82e35ad8c6e8db55c40701fffc3a186685a03eeaf165ff1de92676eef46d4e2fc30a6fac4048701746bf4e994ce37f475e2c216909477ee25ab0fbf88d004da5d82411b0b985c6be394a24da68216134ca06f188259e032e40d458eeeb70c45350a8c4afe6c94632c79fd3efb017e49cdd4a54a2ef82635a9bc7aabf12b93dbabad69cef9988db6ff47831b327c571295f517e7efae4291a296609192c1b291a89bfc183ea5e3c84df424cb8e04d33ee401bff74970d22597ee69ac81c93c6fbec64e201f956d79ba664761e3e6b670763461519b070ab70340a8e16751a6c5b7c7dae4fbf552555ad2b8e786b53e7b2dfeca7b3479e59f83bbce10df53bebea76adbdbee30726babfb72fe09eedefb5dcc3ac211bc10ddf7d9e001e47950a701ffe68f9cee2490e08c98e24e2235a30e3054fcb71256e129747e17d8d6462ab47479f9a1c08231e2f22c1251550a0f6734d706e7da77e308c43038dac7279c68aaa7db4444835e346e24a521bbf3543a7e2495e169094c4fe42d4d9fa385c592914cad1caf617f77ef5b3fd973e22f0f79ce0dc49cc202bbc04b4ddda487da05076f828c21cc4a6d02d2277c2fa96de7ce5cc19ded71728496991f15a71c2c94af8cb85e89ca6d8ebe963242f67a8efec5f55902b39fecf96767304afc9dcb43a7585164b54602ce139d23de08cd04bcaf05a85c8a2bdfdeca678cae3a8cd5e7a3eaddb06c78606e7d8b3b8220dec9c055b9ad3f19625305d1ea62a2f0179927ac827a87f4a70daa82d9974c8a26577c23441012d48c6c80e0579de64dbcca7c98e479bd805b06c9808182946883770673c139c5a8646d88045be388be28dcad9b9f33075ce4e9a97d93a7c69871b9ac5d6ec9eae44d8f2569b3d2d570e616dd8400ffff12140483428b4ff26483ecc4013138c88decc595fe069b94096cebe7033320cafd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"41e821a741d9ff884b11ced13badaeee"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
